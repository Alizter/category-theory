TODO  -*- mode: org; fill-column: 78 -*-

* Inbox
** Define BiCCC characteristics for Cat and Sets
** Instead of HomFunctor, use the closed structure of Cat
And just apply curry to [C^op, C] ⟶ Sets
** Move all instances not related to isomorphism or equivalence into modules
This will prevent Identity from being used whenever 'fmap' is called and I've
forgotten to provide the right context.
** Should the identity functor be Identity, or Id?
** Create Theory/Algebra.v, with constructions like Magma, Semigroup, Monoid, etc.
** Move Tuple into Coq/Tuple, etc.
** DONE Discrete has no arrows; rename the current one to Concrete
** Monad Transformers
** CANCELED Should Cat be moved into Functor.v?
** DONE Make Distributive into a structure, which every BiCCC automatically satisfies
** DONE Create dom(f) and cod(f) functions
* Proofs
** Prod ⊣ Diag ⊣ Coprod
** Show that exp_prod, prod_coprod and exp_coprod arise from adjunctions
Some of these involve the diagonal functor.
** Awodey Theorem 1.6
Every category C with a set of arrows is isomorphic to one in which the
objects are sets and the arrows are functions.
** Awodey Exercise 1.13
Use the Cayley representation to show that every small category is isomorphic
to a “concrete” one, that is, one in which the objects are sets and the arrows
are functions between them.
** Awodey Exercise 1.14
The notion of a category can also be defined with just one sort (arrows)
rather than two (arrows and objects); the domains and codomains are taken to
be certain arrows that act as units under composition, which is partially
defined. Read about this definition in section I.1 of Mac Lane’s Categories
for the Working Mathematician, and do the exercise mentioned there, showing
that it is equivalent to the usual definition.
** "Coyoneda lemma" states that every presheaf is a colimit of representables
* Theory
** Colimit
** Pullback
** Pushout
** Faithful, Full, Fully Faithful functors (inj, surj, bi, resp.)
** Functoral strength
** Kan extensions
** DONE Diagram
** DONE Cone
** DONE Limit
* Constructions
** Free category
** DONE Product (C × D)
** DONE Comma category (F ↓ G)
** DONE Arrow category (C⃗)
** DONE Slice/Coslice (C/c)
* Structures
** Monoidal
*** Monoidal functors
**** "Applicative functors" (strong lax monoidal functors)
** Symmetric
* Instances
** Ensembles (mathematical sets)
** Finite sets
** 3
** Monoid
** Mon
** Graphs
** Homogeneous relations in Prop
** Constructive homogeneous crelations in Type
** DONE 0
** DONE 1
** DONE 2
* Functors
** DONE Diagonal (Δ F)
** Comma category functors
For each comma category there are forgetful functors from it.

    Domain functor, S ↓ T → A
        objects: ( α , β , f ) ↦ α
        morphisms: ( g , h ) ↦ g
    Codomain functor, S ↓ T → B
        objects: ( α , β , f ) ↦ β
        morphisms: ( g , h ) ↦ h
    Arrow functor, S ↓ T → C↓
        objects: ( α , β , f ) ↦ f
        morphisms: ( g , h ) ↦ ( S g , T h )

* Type refinement
Comments from contextualMatters on /r/haskell:

With closed monoidal structure on presheaves, shouldn't it be possible to not
have to deal with point free style though ?

The term would look pretty much like haskell, but with a typing context to
account for the bindings (cf agda code in paper below).

It seems that in this work, Conal extracts from a haskell expression a "pure
categorical" term, in the form of an arrow between types existing in a single
context : the empty context. that is, closed terms. (Then he gains the freedom
to change the meaning of arrows to what he wants).

So he "steals" from haskell the surface language, but he does not "steal" the
binding structure, which is why you have to first remove the bindings. keeping
them means moving away from "type system as categories" and into "type system
as functor" :

In categories, this idea of a binding structure can be represented through
"pre sheaves", which associate to a context C the set of terms inhabiting a
type.

So there is a 2 level structure : above are all those "terms with context",
which is a category, and they can be projected onto a category of "contexts".
you can transport term above a context to terms above another by explicit
operations (corresponding in CS to weakening etc.. the point is those are
really of a different nature).

In the classical math literature, it's linked to the fibration approach. This
treatment for environments is one specific example.

That does not mean fibrations as a general concept is the panacea : they are
actually a very strong requirement, so there is some work to break them apart
in some weaker structure. ( fibrations like structures deal with many other
things (e.g. dependent types but not only)).

Atkey, McKinna etc use terms with environments and provide useful reference
here:

    A Scope Safe Universe of Syntaxes with Binding

Mellies and Zeilberger provide a categorical view for this:

    Isbell duality - (succinct presentation of presheaves)

    Functor are type refinement system
* Colophon
#+STARTUP: content fninline hidestars
#+OPTIONS: ^:{}
#+SEQ_TODO: STARTED TODO APPT WAITING(@) DELEGATED(@) DEFERRED(@) SOMEDAY(@) PROJECT | DONE(@) CANCELED(@) NOTE
#+TAGS: Call(c) Errand(e) Home(h) Net(n) Reply(r)
#+DRAWERS: PROPERTIES LOGBOOK OUTPUT SCRIPT SOURCE DATA
